diff --git a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js
index 332c87d..b39694b 100644
--- a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js
+++ b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js
@@ -116,6 +116,20 @@ class AssetsContractController extends base_controller_1.BaseController {
             return yield this.erc20Standard.getTokenDecimals(address);
         });
     }
+    /**
+     * Query for the decimals for a given ERC20 asset.
+     *
+     * @param address - ERC20 asset contract address.
+     * @returns Promise resolving to the 'decimals'.
+     */
+    getERC20TokenName(address) {
+        return __awaiter(this, void 0, void 0, function* () {
+            if (this.erc20Standard === undefined) {
+                throw new Error(MISSING_PROVIDER_ERROR);
+            }
+            return yield this.erc20Standard.getTokenName(address);
+        });
+    }
     /**
      * Enumerate assets assigned to an owner.
      *
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js
index 9ddbc28..acdc28a 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js
@@ -57,6 +57,27 @@ class ERC20Standard {
             }
         });
     }
+    /**
+     * Query for the name for a given ERC20 asset.
+     *
+     * @param address - ERC20 asset contract string.
+     * @returns Promise resolving to the 'name'.
+     */
+    getTokenName(address){
+        return __awaiter(this, void 0, void 0, function* () {
+            const contract = new contracts_1.Contract(address, metamask_eth_abis_1.abiERC20, this.provider);
+            try {
+                const name = yield contract.name();
+                return name.toString();
+            } catch (err) {
+            // Mirror previous implementation
+            if (err.message.includes('call revert exception')) {
+                throw new Error('Failed to parse token name');
+            }
+            throw err;
+            }
+        });
+    }
     /**
      * Query for symbol for a given ERC20 asset.
      *
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js
index 4ed4990..ebbee48 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js
@@ -34,7 +34,7 @@ class TokenDetectionController extends base_controller_1.BaseController {
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ onPreferencesStateChange, onNetworkStateChange, onTokenListStateChange, getBalancesInSingleCall, addDetectedTokens, getTokenListState, getTokensState, getNetworkState, getPreferencesState, }, config, state) {
+    constructor({ onPreferencesStateChange, onNetworkStateChange, onTokenListStateChange, getBalancesInSingleCall, addDetectedTokens, updateTokensName, getTokenListState, getTokensState, getNetworkState, getPreferencesState, }, config, state) {
         const { providerConfig: { chainId: defaultChainId }, } = getNetworkState();
         const { useTokenDetection: defaultUseTokenDetection } = getPreferencesState();
         super(config, state);
@@ -45,6 +45,7 @@ class TokenDetectionController extends base_controller_1.BaseController {
         this.defaultConfig = Object.assign({ interval: DEFAULT_INTERVAL, selectedAddress: '', disabled: true, chainId: defaultChainId, isDetectionEnabledFromPreferences: defaultUseTokenDetection, isDetectionEnabledForNetwork: (0, assetsUtil_1.isTokenDetectionSupportedForNetwork)(defaultChainId) }, config);
         this.initialize();
         this.getTokensState = getTokensState;
+        this.updateTokensName = updateTokensName;
         this.getTokenListState = getTokenListState;
         this.addDetectedTokens = addDetectedTokens;
         this.getBalancesInSingleCall = getBalancesInSingleCall;
@@ -132,6 +133,9 @@ class TokenDetectionController extends base_controller_1.BaseController {
             const tokensAddresses = tokens.map(
             /* istanbul ignore next*/ (token) => token.address.toLowerCase());
             const { tokenList } = this.getTokenListState();
+            if (tokens.length && !tokens[0].name) {
+                this.updateTokensName(tokenList);
+            }
             const tokensToDetect = [];
             for (const address in tokenList) {
                 if (!tokensAddresses.includes(address)) {
@@ -161,7 +165,7 @@ class TokenDetectionController extends base_controller_1.BaseController {
                         }
                         const caseInsensitiveTokenKey = Object.keys(tokenList).find((i) => i.toLowerCase() === tokenAddress.toLowerCase()) || '';
                         if (ignored === undefined) {
-                            const { decimals, symbol, aggregators, iconUrl } = tokenList[caseInsensitiveTokenKey];
+                            const { decimals, symbol, aggregators, iconUrl, name } = tokenList[caseInsensitiveTokenKey];
                             tokensToAdd.push({
                                 address: tokenAddress,
                                 decimals,
@@ -169,6 +173,7 @@ class TokenDetectionController extends base_controller_1.BaseController {
                                 aggregators,
                                 image: iconUrl,
                                 isERC721: false,
+                                name,
                             });
                         }
                     }
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js
index e3f81e9..8ac1cec 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js
@@ -77,6 +77,7 @@ class TokenRatesController extends base_controller_1.BaseController {
             chainId: '',
             tokens: [],
             threshold: 6 * 60 * 60 * 1000,
+            previousNativeCurrency: '',
         };
         this.defaultState = {
             contractExchangeRates: {},
@@ -93,7 +94,6 @@ class TokenRatesController extends base_controller_1.BaseController {
         });
         onNetworkStateChange(({ providerConfig }) => {
             const { chainId } = providerConfig;
-            this.update({ contractExchangeRates: {} });
             this.configure({ chainId });
         });
         this.poll();
@@ -107,7 +107,7 @@ class TokenRatesController extends base_controller_1.BaseController {
         return __awaiter(this, void 0, void 0, function* () {
             interval && this.configure({ interval }, false, false);
             this.handle && clearTimeout(this.handle);
-            yield (0, controller_utils_1.safelyExecute)(() => this.updateExchangeRates());
+            yield (0, controller_utils_1.safelyExecute)(() => this.updateExchangeRates(true));
             this.handle = setTimeout(() => {
                 this.poll(this.config.interval);
             }, this.config.interval);
@@ -202,7 +202,7 @@ class TokenRatesController extends base_controller_1.BaseController {
     /**
      * Updates exchange rates for all tokens.
      */
-    updateExchangeRates() {
+    updateExchangeRates(forceFetch = false) {
         return __awaiter(this, void 0, void 0, function* () {
             if (this.tokenList.length === 0 || this.disabled) {
                 return;
@@ -217,7 +217,15 @@ class TokenRatesController extends base_controller_1.BaseController {
             }
             else {
                 const { nativeCurrency } = this.config;
-                newContractExchangeRates = yield this.fetchAndMapExchangeRates(nativeCurrency, slug);
+                // Only fetch if native curency is different or when forced (used in polling)
+                if (this.config.previousNativeCurrency !== nativeCurrency || forceFetch) {
+                    newContractExchangeRates = yield this.fetchAndMapExchangeRates(
+                        nativeCurrency,
+                        slug
+                    );
+                } else {
+                    newContractExchangeRates = this.state.contractExchangeRates;
+                }
             }
             this.update({ contractExchangeRates: newContractExchangeRates });
         });
@@ -236,25 +244,29 @@ class TokenRatesController extends base_controller_1.BaseController {
      */
     fetchAndMapExchangeRates(nativeCurrency, slug) {
         return __awaiter(this, void 0, void 0, function* () {
+            // Clear exchange rates before fetching new ones.
+            this.update({ contractExchangeRates: {} });
+            // Set new native currency to prevent this method from being called multiple times
+            this.configure({ previousNativeCurrency: nativeCurrency });
             const contractExchangeRates = {};
-            // check if native currency is supported as a vs_currency by the API
-            const nativeCurrencySupported = yield this.checkIsSupportedVsCurrency(nativeCurrency);
-            if (nativeCurrencySupported) {
-                // If it is we can do a simple fetch against the CoinGecko API
-                const prices = yield this.fetchExchangeRate(slug, nativeCurrency);
-                this.tokenList.forEach((token) => {
-                    const price = prices[token.address.toLowerCase()];
-                    contractExchangeRates[(0, controller_utils_1.toChecksumHexAddress)(token.address)] = price
-                        ? price[nativeCurrency.toLowerCase()]
-                        : 0;
-                });
-            }
-            else {
-                // if native currency is not supported we need to use a fallback vsCurrency, get the exchange rates
-                // in token/fallback-currency format and convert them to expected token/nativeCurrency format.
-                let tokenExchangeRates;
-                let vsCurrencyToNativeCurrencyConversionRate = 0;
-                try {
+            try {
+                // check if native currency is supported as a vs_currency by the API
+                const nativeCurrencySupported = yield this.checkIsSupportedVsCurrency(nativeCurrency);
+                if (nativeCurrencySupported) {
+                    // If it is we can do a simple fetch against the CoinGecko API
+                    const prices = yield this.fetchExchangeRate(slug, nativeCurrency);
+                    this.tokenList.forEach((token) => {
+                        const price = prices[token.address.toLowerCase()];
+                        contractExchangeRates[(0, controller_utils_1.toChecksumHexAddress)(token.address)] = price
+                            ? price[nativeCurrency.toLowerCase()]
+                            : 0;
+                    });
+                }
+                else {
+                    // if native currency is not supported we need to use a fallback vsCurrency, get the exchange rates
+                    // in token/fallback-currency format and convert them to expected token/nativeCurrency format.
+                    let tokenExchangeRates;
+                    let vsCurrencyToNativeCurrencyConversionRate = 0;
                     [
                         tokenExchangeRates,
                         { conversionRate: vsCurrencyToNativeCurrencyConversionRate },
@@ -262,21 +274,23 @@ class TokenRatesController extends base_controller_1.BaseController {
                         this.fetchExchangeRate(slug, controller_utils_1.FALL_BACK_VS_CURRENCY),
                         (0, crypto_compare_1.fetchExchangeRate)(nativeCurrency, controller_utils_1.FALL_BACK_VS_CURRENCY, false),
                     ]);
-                }
-                catch (error) {
-                    if (error instanceof Error &&
-                        error.message.includes('market does not exist for this coin pair')) {
-                        return {};
+                    for (const [tokenAddress, conversion] of Object.entries(tokenExchangeRates)) {
+                        const tokenToVsCurrencyConversionRate = conversion[controller_utils_1.FALL_BACK_VS_CURRENCY.toLowerCase()];
+                        contractExchangeRates[(0, controller_utils_1.toChecksumHexAddress)(tokenAddress)] =
+                            tokenToVsCurrencyConversionRate *
+                                vsCurrencyToNativeCurrencyConversionRate;
                     }
-                    throw error;
-                }
-                for (const [tokenAddress, conversion] of Object.entries(tokenExchangeRates)) {
-                    const tokenToVsCurrencyConversionRate = conversion[controller_utils_1.FALL_BACK_VS_CURRENCY.toLowerCase()];
-                    contractExchangeRates[(0, controller_utils_1.toChecksumHexAddress)(tokenAddress)] =
-                        tokenToVsCurrencyConversionRate *
-                            vsCurrencyToNativeCurrencyConversionRate;
                 }
+            } catch (error) {
+                // If there is an error catched we clean the state
+                this.update({ contractExchangeRates: {} });
+                if (error instanceof Error &&
+                    error.message.includes('market does not exist for this coin pair')) {
+                    return {};
+                    }
+                throw error;
             }
+
             return contractExchangeRates;
         });
     }
diff --git a/node_modules/@metamask/assets-controllers/dist/TokensController.js b/node_modules/@metamask/assets-controllers/dist/TokensController.js
index 0e03b88..4921452 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokensController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokensController.js
@@ -49,8 +49,9 @@ class TokensController extends base_controller_1.BaseController {
      * @param options.config - Initial options used to configure this controller.
      * @param options.state - Initial state to set on this controller.
      * @param options.messenger - The controller messenger.
+     * @param options.getERC20TokenName - Allows fetch an ERC-20 token name
      */
-    constructor({ onPreferencesStateChange, onNetworkStateChange, config, state, messenger, }) {
+    constructor({ onPreferencesStateChange, onNetworkStateChange, config, state, messenger, getERC20TokenName, }) {
         super(config, state);
         this.mutex = new async_mutex_1.Mutex();
         /**
@@ -66,6 +67,7 @@ class TokensController extends base_controller_1.BaseController {
         this.initialize();
         this.abortController = new abort_controller_1.AbortController();
         this.messagingSystem = messenger;
+        this.getERC20TokenName = getERC20TokenName;
         onPreferencesStateChange(({ selectedAddress }) => {
             var _a, _b, _c;
             const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
@@ -130,9 +132,10 @@ class TokensController extends base_controller_1.BaseController {
      * @param decimals - Number of decimals the token uses.
      * @param image - Image of the token.
      * @param interactingAddress - The address of the account to add a token to.
+     * @param name - Name of the token.
      * @returns Current token list.
      */
-    addToken(address, symbol, decimals, image, interactingAddress) {
+    addToken(address, symbol, decimals, image, interactingAddress, name) {
         var _a, _b, _c;
         return __awaiter(this, void 0, void 0, function* () {
             const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
@@ -164,6 +167,7 @@ class TokensController extends base_controller_1.BaseController {
                         }),
                     isERC721,
                     aggregators: (0, assetsUtil_1.formatAggregatorNames)((tokenMetadata === null || tokenMetadata === void 0 ? void 0 : tokenMetadata.aggregators) || []),
+                    name,
                 };
                 const previousEntry = newTokens.find((token) => token.address.toLowerCase() === address.toLowerCase());
                 if (previousEntry) {
@@ -215,7 +219,7 @@ class TokensController extends base_controller_1.BaseController {
             }, {});
             try {
                 tokensToImport.forEach((tokenToAdd) => {
-                    const { address, symbol, decimals, image, aggregators } = tokenToAdd;
+                    const { address, symbol, decimals, image, aggregators, name } = tokenToAdd;
                     const checksumAddress = (0, controller_utils_1.toChecksumHexAddress)(address);
                     const formattedToken = {
                         address: checksumAddress,
@@ -223,6 +227,7 @@ class TokensController extends base_controller_1.BaseController {
                         decimals,
                         image,
                         aggregators,
+                        name,
                     };
                     newTokensMap[address] = formattedToken;
                     importedTokensMap[address.toLowerCase()] = true;
@@ -298,7 +303,7 @@ class TokensController extends base_controller_1.BaseController {
             let newDetectedTokens = [...detectedTokens];
             try {
                 incomingDetectedTokens.forEach((tokenToAdd) => {
-                    const { address, symbol, decimals, image, aggregators, isERC721 } = tokenToAdd;
+                    const { address, symbol, decimals, image, aggregators, isERC721, name } = tokenToAdd;
                     const checksumAddress = (0, controller_utils_1.toChecksumHexAddress)(address);
                     const newEntry = {
                         address: checksumAddress,
@@ -307,6 +312,7 @@ class TokensController extends base_controller_1.BaseController {
                         image,
                         isERC721,
                         aggregators,
+                        name,
                     };
                     const previousImportedEntry = newTokens.find((token) => token.address.toLowerCase() === checksumAddress.toLowerCase());
                     if (previousImportedEntry) {
@@ -373,6 +379,20 @@ class TokensController extends base_controller_1.BaseController {
             return tokens[tokenIndex];
         });
     }
+    /**
+     * This is a function that updates the tokens name for the tokens name if it is not defined
+     * @param tokenList - Represents the fetched token list from service API 
+     */
+    async updateTokensName(tokenList) {
+        const { tokens } = this.state;
+    
+        const newTokens = tokens.map((token) => {
+            const newToken = tokenList[token.address.toLowerCase()];
+          return (!token.name && newToken?.name) ? { ...token, name: newToken.name } : {...token};
+        });
+    
+        this.update({ tokens: newTokens });
+    }
     /**
      * Detects whether or not a token is ERC-721 compatible.
      *
@@ -484,7 +504,13 @@ class TokensController extends base_controller_1.BaseController {
                 switch (suggestedAssetMeta.type) {
                     case 'ERC20':
                         const { address, symbol, decimals, image } = suggestedAssetMeta.asset;
-                        yield this.addToken(address, symbol, decimals, image, (suggestedAssetMeta === null || suggestedAssetMeta === void 0 ? void 0 : suggestedAssetMeta.interactingAddress) || selectedAddress);
+                        let name;
+                        try {
+                            name = yield this.getERC20TokenName(address);
+                        } catch(error){
+                            name = undefined;
+                        }
+                        yield this.addToken(address, symbol, decimals, image, (suggestedAssetMeta === null || suggestedAssetMeta === void 0 ? void 0 : suggestedAssetMeta.interactingAddress) || selectedAddress, name);
                         this._acceptApproval(suggestedAssetID);
                         const acceptedSuggestedAssetMeta = Object.assign(Object.assign({}, suggestedAssetMeta), { status: SuggestedAssetStatus.accepted });
                         this.hub.emit(`${suggestedAssetMeta.id}:finished`, acceptedSuggestedAssetMeta);
